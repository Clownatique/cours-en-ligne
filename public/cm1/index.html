<script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><p>application: c lappel dune fonction avec des parametres
typable: avoir le choix de la reduction
beta reduction: (lambda x. E f) \rightarrow E [x:= f] (c quand on remplace les parametres donnes par les parametres formels)</p>
<p>et donc pour beta reduire il faut reconnaitre (lambda x.E f) avec E et f des ..</p>
<p>lambda terme :3 choses</p>
<p>un lambda implique une abstraction(on peut le voir comme une definition anonyme)</p>
<p>ceci est un **&gt;</p>
<h2 id="e">e</h2>
<h1 id="1-introduction">1. Introduction</h1>
<p>Le lambda-calcul est un système formel inventé par Alonzo Church dans les années 1930 pour étudier les fonctions et la calculabilité. C&rsquo;est le fondement théorique de la programmation fonctionnelle.</p>
<h1 id="2-expressions-lambda-termes">2. Expressions Lambda (Termes)</h1>
<h2 id="définition-récursive">Définition récursive</h2>
<p>Une expression lambda (ou terme) est définie par :</p>
<p><strong>Variable</strong> : x, y, z, etc.
Une variable c vrm simplement un symbole, libre ou pas, fonction ou pas, defini ou pas, c juste un symbole</p>
<h3 id="variables-liées">Variables liées</h3>
<p>Dans λx.M, x est liée dans M (comme paramètre formel).</p>
<h3 id="variables-libres">Variables libres</h3>
<p>Une variable qui n&rsquo;est pas liée par une abstraction englobante.</p>
<p>Définition formelle de FV(M) (variables libres) :</p>
<pre><code>FV(x) = {x}

FV(λx.M) = FV(M) \ {x}

FV(M N) = FV(M) ∪ FV(N)
</code></pre>
<p>Exemple : FV(λx.x y) = {y}</p>
<p><strong>Abstraction</strong>: Si x est une variable et M un terme, alors λx.M est une abstraction.
On apporte a notre symbole une autre maniere detre interprete: un calcul pour rester simple, mais aussi une autre fonction</p>
<p><strong>Application</strong>: Si M et N sont des termes, alors (M N) est une application.
Une maniere dutiliser nos supers symboles (qui sont des fonctions definis grace a des expressions)</p>
<h2 id="conventions-décriture">Conventions d&rsquo;écriture</h2>
<h3 id="élision-des-parenthèses-">Élision des parenthèses :</h3>
<p><strong>Application associative à gauche</strong>:</p>
<p>M N P signifie ((M N) P)</p>
<p>Le corps d&rsquo;une abstraction s&rsquo;étend aussi loin que possible : λx.M N signifie λx.(M N)</p>
<p>On peut omettre les parenthèses externes</p>
<h3 id="abbréviations-">Abbréviations :</h3>
<p>si on a deux symboles cote a cote dans une abstraction</p>
<p>λxy.M pour λx.λy.M
λx y z.M pour λx.λy.λz.M</p>
<h1 id="3-abstraction">3. Abstraction</h1>
<p>Une abstraction λx.M donne une autre interpretation au x: elle pourra aussi donner M
On dira alors que x est lie dans M</p>
<p>M est une autre expression</p>
<h1 id="4-application">4. Application</h1>
<p>Notation: (M N) signifie &ldquo;appliquer la fonction M à l&rsquo;argument N&rdquo;.
Exemple : (λx.x) y → applique la fonction identité à y</p>
<h1 id="5-les-calculs-du-lambda-calcul">5. les &ldquo;calculs&rdquo; du lambda calcul</h1>
<h2 id="substitution">substitution</h2>
<p>Notation: expr[variable-1 := variable-2] signifie &ldquo;remplacer les occurrences <strong>libres</strong> de x dans M par N&rdquo;.</p>
<h3 id="exemples-importants">Exemples importants</h3>
<p>x[x := N] = N (c le concept dcp)
y[x := N] = y si y ≠ x (bah oui parce que x n)
(M₁ M₂)[x := N] = (M₁[x := N]) (M₂[x := N]) (oui ca marche aussi avec les applications !)
(λy.M)[x := N] = λy.(M[x := N]) si y ≠ x et y ∉ FV(N) (on peut pas subtituer le premier y !! sinon on change la semantique)</p>
<h3 id="pourquoi-ne-pas-subtituer-trop-vite">Pourquoi ne pas subtituer trop vite</h3>
<p>Quand on souhaite faire une subtitution sur une abstraction,
si la nouvelle variable devient la variable quon est en train de lier&hellip; ca namene a rien de bon
Si on veut &ldquo;subtituer&rdquo; une abstraction par une autre variable on prefere faire un renommage</p>
<h2 id="renommage-α-conversion-ou-subtitution-de-variable-deja-lies">Renommage (α-conversion), ou subtitution de variable deja lies</h2>
<p>λx.M peut être renommé en λy.M[x:=y] si y nest pas deja pris cela va de soit
Exemple : λx.x ≡α λy.y</p>
<p>Convention : On considère le symbole modulo pour l&rsquo;α-conversion.</p>
<h2 id="une-super-renommage--la-réduction-β-réduction">Une super renommage : la réduction (β-réduction)</h2>
<p>Les betas reduction nagissent que sur des idees deja en cours dexpression (les applications)
La règle de calcul fondamentale :</p>
<p>(λx.M) N →β M[x := N]</p>
<h3 id="stratégies-de-réduction">Stratégies de réduction</h3>
<p>Normale : réduire la rédex la plus à gauche la plus externe
Applicative : réduire la rédex la plus à gauche la plus interne
Par valeur : réduire seulement quand l&rsquo;argument est une valeur</p>
<p>Et cest quand quon sarrete de reduire comme un beta ?
Les gens un peu beta (de droite notamment), reduisent et invisibilise ce dont ils ont peur.
Dcp, quand un mec devient normale, ils arretent de le reduire.</p>
<p>C pareil ici, quand on a epuise nos peurs, on peut plus trop reduire quoi que ce soit (soi meme peut etre ? pas dans ce cours)
Les betas reduction nagissent que sur des idees deja en cours dexpression (les applications)</p>
<blockquote>
<p>Un terme est en forme normale s&rsquo;il ne contient aucune β-rédex.</p>
</blockquote>
<h1 id="6-représentation-arborescente-des-expressions">6. Représentation Arborescente des expressions</h1>
<p>Syntaxe des arbres (non enracine, on devrait donc plutot parler de <a href="https://fr.wikipedia.org/wiki/Stolon_(organe)">https://fr.wikipedia.org/wiki/Stolon_(organe)</a> )</p>
<p>p
Nœud λ : λx avec un sous-arbre
Nœud d&rsquo;application : @ avec deux sous-arbres
Feuille : variable x (a la fin donc !)</p>
<h1 id="10-rajout-a-tout-ce-bazar-de-larithmetique">10. Rajout a tout ce bazar de larithmetique</h1>
<p>Parce que oui, c a partir de la quon devrait sarreter normalement! mais ya des foudingues qui ont voulu pousser le bouchon..
Evidemment, c cool pour y trouver un interet de voir des champs dapplication</p>
<h2 id="les-eniters-de-church">Les eniters de church</h2>
<pre><code>0 := λf.λx.x (donc renvoie cette fonction qui renvoie une fonction qui se renvoie elle meme)
1 := λf.λx.f x (et on lui reapplique 0)
2 := λf.λx.f (f x) (et on applique a f ce qui donnait 1)
n := λf.λx.f^n x (et la on vit hein)
</code></pre>
<h2 id="opérateurs-arithmétiques">Opérateurs Arithmétiques</h2>
<h3 id="successeur">Successeur</h3>
<p>SUCC := λn.λf.λx.f (n f x)</p>
<p>Vérification : SUCC n = λf.λx.f (n f x) = λf.λx.f (f^n x) = λf.λx.f^{n+1} x = n+1</p>
<h3 id="addition">Addition</h3>
<p>PLUS := λm.λn.λf.λx.m f (n f x)</p>
<p>Car m f (n f x) = f^m (f^n x) = f^{m+n} x</p>
<h3 id="multiplication">Multiplication</h3>
<p>MULT := λm.λn.λf.m (n f)</p>
<p>Car m (n f) = (f^n)^m = f^{m*n}</p>
<h2 id="quelques-booleens">quelques booleens</h2>
<h3 id="test-à-zéro">Test à zéro</h3>
<p>ISZERO := λn.n (λx.FALSE) TRUE</p>
<p>où TRUE := λx.λy.x et FALSE := λx.λy.y</p>
<h1 id="11-typage-dans-le-lambda-calcul">11. Typage dans le Lambda-Calcul</h1>
<p>Le typage permets de faire des distinctions entre les expressions.</p>
<p>C&rsquo;est un peu comme un videur en boite.
Il nomme un peu tout ce qui bouge et ressemble a ca</p>
<p>:</p>
<p>Son boss, c un mec un peu tordu, il ressemble a ca</p>
<p>Γ</p>
<p>C un mec, qui ordonne au videur de type des trucs</p>
<p>∅ Γ 2 + 3</p>
<p>et le videur il reponds</p>
<p>∅ Γ 2 + 3: number</p>
<p>parfois, le boss lui donne des conseils</p>
<p>{x : number} Γ x + 3 : number</p>
<p>Bref, jai eviter de dire c un type un peu perdu sinon je vous aurais casse le crane aha</p>
<p>De ces types de variables, on amene alors le fait que
une variable peut renvoyer une variable.
Et le fait que une variable en renvoie une autre c en soit un type. c le type fonction. (et on le note -&gt;)</p>
<h2 id="règles-de-typage">Règles de typage</h2>
<p>Variable : Si x:τ ∈ Γ, alors Γ ⊢ x:τ
si notre videur vois un mec (une variable) arrive, il dit quel genre de mec c</p>
<p>Abstraction : Si Γ, x:τ ⊢ M:σ, alors Γ ⊢ (λx:τ.M):τ → σ
si notre videur vois un mec qui pense a un truc, a une maniere de faire,
il repete qui c, et ce quil a pense</p>
<p>ce sera pas un peu plus quun videur ??</p>
<p>Application : Si Γ ⊢ M:τ → σ et Γ ⊢ N:τ, alors Γ ⊢ (M N):σ
si notre videur vois un mec qui pense a un truc, a une maniere de faire, et quil applique ce quil pense</p>
<p>alors le videur va juste dire ce quil sest passe a la fin.
sans meme se demander ce qui lui est passe par la tete.
Une vrai comere ce type.</p>
<p>Exemples</p>
<p>Identité : λx:A.x : A → A ()
Application : (λx:A→B.x) (λy:A.y) : A → B</p>
<p>Notation des types</p>
<p>Les types de fonction sont associatifs à droite : A → B → C signifie A → (B → C)
Il est un peu de droite ce videur</p>
<p>On peut omettre les parenthèses suivant cette convention
En plus, parfois il sen bat la race de garder le politiquement correcte.</p>
<h1 id="12-conventions-décriture-complètes">12. Conventions d&rsquo;Écriture Complètes</h1>
<h2 id="priorités">Priorités</h2>
<p>Application : la plus haute priorité
Abstraction : λx.M N signifie λx.(M N)
Flèche de type : → a la plus basse priorité</p>
<p>Élisions courantes</p>
<p>λxyz.M pour λx.λy.λz.M
M N P pour ((M N) P)
λx:A→B.M pour λx:(A→B).M</p>
<p>Variables et métavariables</p>
<p>Lettres minuscules : variables du lambda-calcul (x, y, z)
des bons a rien finalement, il font juste bonne figure</p>
<p>Lettres majuscules : métavariables pour les termes (M, N, P)
ca en general, c les trucs qui prennent la tete, et qui prennent la grosse tete</p>
<p>Lettres grecques : types (α, β, τ, σ)
notre videur a pris grec ancien au college. Comme quoi&hellip;</p>
<p>Conclusion</p>
<p>Le lambda-calcul est un système minimaliste mais puissant qui capture l&rsquo;essence du calcul fonctionnel. Ses concepts fondamentaux (abstraction, application, substitution) et ses propriétés (confluence, normalisation) en font un outil théorique essentiel en informatique.</p>
<p>Pour approfondir : le lambda-calcul avec types dépendants, les systèmes de types avancés (System F), et les liens avec la logique (correspondance de Curry-Howard).</p>
<p>Merci DeepSeek !!</p>

<script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><h2 id="petits-rappels-de-notations">petits rappels de notations</h2>
<p>$$ \lambda x f(x)\equiv $$</p>
<p>une abstraction
appel dune fonction:
toutes les fonctions sont anonymes (en lambda calcul)</p>
<p>tsais jai limpression le lambda calcul c une histoire de recreer le typage</p>
<p>((lamda f lambda x (f x)lambda y (y+y)) 5) rightarrow (lambda x (f x [f := lambda y . y^2]))
= (lambda x . (lambda y . y^2 x)_E 5_f)
rightarrow^x (lambda y y^2 x)[x:=5]
= (lambda y . y^2 5)
rightarrow y^2 [y=5]=5^2=25</p>
<p>2 beta reductions
d</p>
<h2 id="td-1-exo-1-5-super-fonction-a-2-parametres">td 1 exo 1. 5) (super fonction a 2 parametres)</h2>
<p>$$ (lambda x (lambda y(x+y) x ) 5)$$</p>
<p>sous forme dun arbre:
(@((\lambda x (@ (\lambda y x+y)x n))5))</p>
<h3 id="faire-2-beta-reduction-en-partant-de-lexterieur-vers-linterieur-a-faire">faire 2 beta reduction en partant de lexterieur vers linterieur (a faire)</h3>
<p>on devrait trouver 10</p>
<h3 id="faire-x-beta-reduction-en-partant-de-linterieur-vers-lexterieura-faire">faire x beta reduction en partant de linterieur vers lexterieur(a faire)</h3>
<p>pareil</p>
<p>=&gt; ocaml utilise la premiere strategie</p>
<h2 id="td-1-exo-6">td 1 exo 6)</h2>
<p>(lambda x ((x lambda y (y+z))+(x lambda z (z * 3))) (lambda u . lambda w (w u )5))</p>
<p>donc faut trouver que ce truc est bien un number.</p>
<p>enft le but de lexo c de trouver le type des fonctions.
pour ca, en partant du bas, on remonte de larbre en faisant gaffe a ce qui est dit dans lenonce</p>
<h2 id="td-1-exo-12">td 1 exo 12</h2>
<p>(lambda x.(x+5) (lambda z z 2))</p>
